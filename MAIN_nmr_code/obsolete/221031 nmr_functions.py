import csv
import math
import os

import matplotlib
from scipy.optimize import curve_fit

import matplotlib.pyplot as plt
from nmr_std_function import data_parser
from nmr_std_function.data_parser import convert_to_prospa_data_t1
from nmr_std_function.signal_proc import down_conv, nmr_fft, butter_lowpass_filter
import numpy as np


def plot_echosum( nmrObj, filepath, samples_per_echo, echoes_per_scan, en_fig ):

    dat1 = np.array( data_parser.read_data( filepath ) )  # use ascii representation
    dat2 = np.reshape(dat1, ( echoes_per_scan, samples_per_echo))
    dat3 = np.mean(dat2,0)
    
    # plot the individual echoes
    plt.figure(0)
    for i in range(echoes_per_scan):
        plt.plot(dat2[i,:], color='y')
    
    # plot the echo sum
    # plt.figure(1)    
    plt.plot(dat3, color='blue')
    
    plt.show()

def compute_multiple( nmrObj, phenc_conf, expt_num, sav_fig, show_fig):

    # variables to be input
    # data_parent_folder : the folder for all datas
    # meas_folder        : the specific folder for one measurement
    # show_fig            : enable figure
    # en_ext_rotation      : enable external reference for rotation angle
    # thetaref          : external parameter : rotation angle
    # en_conj_matchfilter    : when true, matchfilter is computed with conjugate of the echo_avg. When false, matchfilter is computed only with amplitude of the echo_avg, so no rotation will be performed
    # en_ext_matchfilter : enable external reference for matched filtering
    # echoref_avg        : external parameter : echo average reference
    # ignore_echoes     : ignore initial echoes for calculation of echo_avg, T2 fitting, and SNR. It's still being shown in the plot to keep the information.

    # data_folder = ( data_parent_folder + '/' + meas_folder + '/' )
    data_folder = nmrObj.client_data_folder + nmrObj.folder_extension
    
    # load variables from phenc configs
    en_ext_rotation = phenc_conf.en_ext_rotation
    thetaref = phenc_conf.thetaref
    en_conj_matchfilter = phenc_conf.en_conj_matchfilter
    en_ext_matchfilter = phenc_conf.en_ext_matchfilter
    echoref_avg = phenc_conf.echoref_avg
    dconv_lpf_ord = phenc_conf.dconv_lpf_ord
    dconv_lpf_cutoff_kHz = phenc_conf.dconv_lpf_cutoff_kHz
    ignore_echoes = phenc_conf.ignore_echoes
    dual_exp = phenc_conf.dual_exp # set to 1 for dual exponential fit. Otherwise, it will be single exponential fit
    
    
    # variables local to this function the setting file for the measurement
    mtch_fltr_sta_idx = 0  # 0 is default or something referenced to SpE, e.g. SpE/4; the start index for match filtering is to neglect ringdown part from calculation 
    en_self_rotation = True # perform rotation to the data -> required for reference data for t1 measurement
    proc_indv_data = False # process individual raw data, otherwise it'll load a sum file generated by C
    binary_OR_ascii = True # put 1 if the data file uses binary representation, otherwise it is in ascii format
    unit__uvolt_or_digit = False # set to 0 of ADC digit unit, or 1 for microvolt unit for all the plot 
    

    # sav_fig = False  # compute the figure and save the figure to file. To show it in runtime, enable the show_fig
    sav_indv_dat = False # save individual computed data
    
    # file name prefix for individual data
    file_name_prefix = 'dat_'
    
    # variables from NMR settings
    ( param_list, value_list ) = data_parser.parse_info( data_folder, 'acqu_%06d.par' % expt_num )  # read file
    SpE = int( data_parser.find_value( 'nrPnts', param_list, value_list ) )
    NoE = int( data_parser.find_value( 'nrEchoes', param_list, value_list ) )
    en_ph_cycle_proc = int (data_parser.find_value( 'usePhaseCycle', param_list, value_list ))
    tE = data_parser.find_value( 'echoTimeRun', param_list, value_list )
    Sf = data_parser.find_value( 'adcFreq', param_list, value_list ) * 1e6
    Df = data_parser.find_value( 'b1Freq', param_list, value_list ) * 1e6
    total_scan = int( data_parser.find_value( 'nrIterations', param_list, value_list ) )
    echo_skip = data_parser.find_value( 'echoSkipHw', param_list, value_list )

    # account for skipped echoes
    NoE = int( NoE / echo_skip )
    tE = tE * echo_skip

    # time domain for plot
    tacq = ( 1 / Sf ) * 1e6 * np.linspace( 1, SpE, SpE )  # in uS
    t_echospace = tE / 1e6 * np.linspace( 1, NoE, NoE )  # in uS

    if ( proc_indv_data ):
        # read all datas and average it
        data = np.zeros( NoE * SpE )
        for m in range( 1, total_scan + 1 ):
            file_path = ( data_folder + file_name_prefix +
                         '{0:03d}'.format( m ) )
            # read the data from the file and store it in numpy array
            # format
            one_scan = np.array( data_parser.read_data( file_path ) )
            one_scan = ( one_scan - np.mean( one_scan ) ) / \
                total_scan  # remove DC component
            if ( en_ph_cycle_proc ):
                if ( m % 2 ):  # phase cycling every other scan
                    data = data - one_scan
                else:
                    data = data + one_scan
            else:
                data = data + one_scan
        
        dataraw = data        
        
    else:
        # read sum data only
        file_path = ( data_folder + '\\dsum_%06d.txt' % expt_num )
        data = np.zeros( NoE * SpE )

        if binary_OR_ascii:
            # data = data_parser.read_hex_float( file_path )  # use binary representation
            data = data_parser.read_hex_int32 (file_path) # read int32 in binary representation
        else:
            data = np.array( data_parser.read_data( file_path ) ) # use ascii representation

        dataraw = data
        data = ( data - np.mean( data ) )

    # ignore echoes
    # if ignore_echoes:
    #    NoE = NoE - ignore_echoes
    #    data = data[ignore_echoes * SpE:len( data )]
    
    if (unit__uvolt_or_digit): # use either microvolt or digit (adc output) unit
        # compute the probe voltage before gain stage
        data = data / nmrObj.totGain * nmrObj.uvoltPerDigit
    

    if sav_fig:  # plot the averaged scan
        echo_space = ( 1 / Sf ) * np.linspace( 1, SpE, SpE )  # in s
        plt.figure( 1 )
        plt.clf()
        for i in range( 1, NoE + 1 ):
            # plt.plot(((i - 1) * tE * 1e-6 + echo_space) * 1e3, data[(i - 1) * SpE:i * SpE], linewidth=0.4)
            plt.plot( ( ( i - 1 ) * tE * 1e-6 + echo_space ) * 1e3, dataraw[( i - 1 ) * SpE:i * SpE], linewidth = 0.4 )
        plt.title( "Averaged raw data" )
        plt.xlabel( 'time(ms)' )
        if (unit__uvolt_or_digit): # use either microvolt or digit (adc output) unit
            plt.ylabel( 'probe voltage (uV)' )
        else:
            plt.ylabel( 'adc out (digit)' )
        plt.savefig( data_folder + '\\decay_raw.png' )

    # raw average data
    echo_rawavg = np.zeros( SpE, dtype = float )
    for i in range( ignore_echoes, NoE ):
        echo_rawavg += ( data[i * SpE:( i + 1 ) * SpE] / (NoE-ignore_echoes) )

    if sav_fig:  # plot echo rawavg
        plt.figure( 6 )
        plt.clf()
        plt.plot( tacq, echo_rawavg, label = 'echo rawavg' )
        plt.xlim( 0, max( tacq ) )
        plt.title( "Echo Average (raw)" )
        plt.xlabel( 'time(uS)' )
        if (unit__uvolt_or_digit): # use either microvolt or digit (adc output) unit
            plt.ylabel( 'probe voltage (uV)' )
        else:
            plt.ylabel( 'adc out (digit)' )
        plt.legend()
        plt.savefig( data_folder + '\\echo_avg.png' )

    # filter the data
    data_filt = np.zeros( ( NoE, SpE ), dtype = complex )
    for i in range( 0, NoE ):
        data_filt[i, :] = down_conv( data[i * SpE:( i + 1 ) * SpE], i, tE, Df, Sf, dconv_lpf_ord, dconv_lpf_cutoff_kHz * 1e3 )

    # scan rotation
    if en_ext_rotation:
        data_filt = data_filt * np.exp( -1j * thetaref )
        theta = math.atan2( np.sum( np.imag( data_filt[ignore_echoes:,:] ) ),
                           np.sum( np.real( data_filt[ignore_echoes:,:] ) ) )
    else:
        theta = math.atan2( np.sum( np.imag( data_filt[ignore_echoes:,:] ) ),
                           np.sum( np.real( data_filt[ignore_echoes:,:] ) ) )
        if en_self_rotation:
            data_filt = data_filt * np.exp( -1j * theta )

    if sav_fig:  # plot filtered data
        echo_space = ( 1 / Sf ) * np.linspace( 1, SpE, SpE )  # in s
        plt.figure( 2 )
        plt.clf()
        
        if sav_indv_dat:
            data_parser.write_text_overwrite( data_folder, "\\decay_filt.txt", "settings: NoE: %d, SpE: %d, tE: %0.2f, fs: %0.2f. Format: re(echo1), im(echo1), re(echo2), im(echo2), ... " % ( NoE, SpE, tE, Sf ) )

        for i in range( 0, NoE ):
            plt.plot( ( i * tE * 1e-6 + echo_space ) * 1e3, np.real( data_filt[i, :] ), 'b', linewidth = 0.4 )
            plt.plot( ( i * tE * 1e-6 + echo_space ) * 1e3, np.imag( data_filt[i, :] ), 'r', linewidth = 0.4 )
        
        if sav_indv_dat:
            for i in range ( 0, NoE ):
                data_parser.write_text_append_row( data_folder, "\\decay_filt.txt", np.real( data_filt[i, :] ) )
                data_parser.write_text_append_row( data_folder, "\\decay_filt.txt", np.imag( data_filt[i, :] ) )

        plt.legend()
        plt.title( 'Filtered data' )
        plt.xlabel( 'Time (mS)' )
        if (unit__uvolt_or_digit): # use either microvolt or digit (adc output) unit
            plt.ylabel( 'probe voltage (uV)' )
        else:
            plt.ylabel( 'adc out (digit)' )
        plt.savefig( data_folder + '\\decay_filt.png' )

    # find echo average, echo magnitude
    echo_avg = np.zeros( SpE, dtype = complex )
    for i in range( ignore_echoes, NoE ):
        echo_avg += ( data_filt[i, :] / NoE )
    echo_avg_rms = np.sqrt(np.sum(np.multiply(np.abs(echo_avg),np.abs(echo_avg)))) # find the rms value

    if sav_fig:  # plot echo shape
        plt.figure( 3 )
        plt.clf()
        plt.plot( tacq, np.abs( echo_avg ), label = 'abs' )
        plt.plot( tacq, np.real( echo_avg ), label = 'real part' )
        plt.plot( tacq, np.imag( echo_avg ), label = 'imag part' )
        plt.xlim( 0, max( tacq ) )
        plt.title( "Echo Shape" )
        plt.xlabel( 'time(uS)' )
        if (unit__uvolt_or_digit): # use either microvolt or digit (adc output) unit
            plt.ylabel( 'probe voltage (uV)' )
        else:
            plt.ylabel( 'adc out (digit)' )
        plt.legend()
        plt.savefig( data_folder + '\\echo_shape.png' )
        
        if sav_indv_dat:
            data_parser.write_text_overwrite( data_folder, "\\echo_shape.txt", "format: abs, real, imag, time_us" )
            data_parser.write_text_append_row( data_folder, "\\echo_shape.txt", np.abs( echo_avg ) )
            data_parser.write_text_append_row( data_folder, "\\echo_shape.txt", np.real( echo_avg ) )
            data_parser.write_text_append_row( data_folder, "\\echo_shape.txt", np.imag( echo_avg ) )
            data_parser.write_text_append_row( data_folder, "\\echo_shape.txt", tacq )

        # plot echo spectrum
        plt.figure( 4 )
        plt.clf()
        zf = 10  # zero filling factor to get smooth curve. Factor 1 means the resulting vector length is added by the amount of the original vector length itself.
        if zf>0: # process zero filling
            ws = 2 * np.pi / ( tacq[1] - tacq[0] )  # in MHz
            wvect = np.linspace( -ws / 2, ws / 2, len( tacq ) * zf )
            echo_zf = np.zeros( zf * len( echo_avg ), dtype = complex )
            echo_zf[int( ( zf / 2 ) * len( echo_avg ) - len( echo_avg ) / 2 ): int( ( zf / 2 ) * len( echo_avg ) + len( echo_avg ) / 2 )] = echo_avg
            spect = zf * ( np.fft.fftshift( np.fft.fft( np.fft.ifftshift( echo_zf ) ) ) )
            spect = spect / len( spect )  # normalize the spectrum
        else: #ignore zero filling
            ws = 2 * np.pi / ( tacq[1] - tacq[0] )  # in MHz
            wvect = np.linspace( -ws / 2, ws / 2, len( tacq ) )
            spect =  ( np.fft.fftshift( np.fft.fft( np.fft.ifftshift( echo_avg ) ) ) )
            spect = spect / len(spect)
            
        plt.plot( wvect / ( 2 * np.pi ), np.real( spect ), label = 'real' )
        plt.plot( wvect / ( 2 * np.pi ), np.imag( spect ), label = 'imag' )
        plt.xlim( 10 / max( tacq ) * -1, 10 / max( tacq ) * 1 )
        plt.title( "Echo spectrum. " + "Peak:real@{:0.2f}kHz,abs@{:0.2f}kHz".format( wvect[np.abs( np.real( spect ) ) == max( 
            np.abs( np.real( spect ) ) )][0] / ( 2 * np.pi ) * 1e3, wvect[np.abs( spect ) == max( np.abs( spect ) )][0] / ( 2 * np.pi ) * 1e3 ) )
        plt.xlabel( 'offset frequency(MHz)' )
        plt.ylabel( 'Echo amplitude (a.u.)' )
        plt.legend()
        plt.savefig( data_folder + '\\echo_spect.png' )
        
        if sav_indv_dat:
            data_parser.write_text_overwrite( data_folder, "\\echo_spect.txt", "format: real, imag, freq_MHz" )
            data_parser.write_text_append_row( data_folder, "\\echo_spect.txt", np.real( spect ) )
            data_parser.write_text_append_row( data_folder, "\\echo_spect.txt", np.imag( spect ) )
            data_parser.write_text_append_row( data_folder, "\\echo_spect.txt", wvect / ( 2 * np.pi ) )

    # matched filtering
    a = np.zeros( NoE, dtype = complex )
    for i in range( 0, NoE ):
        if en_conj_matchfilter:
            if en_ext_matchfilter:
                # find amplitude with reference echo
                # a[i] = np.sqrt(np.mean( np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.conj( echoref_avg[mtch_fltr_sta_idx:SpE] ) ) ) ) # sqrt(echo*echo_conjugate) --- wrong! because the echo average is a constant multiplier that does not change T2, but sqrt changes T2.
                a[i] = np.mean( np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.conj( echoref_avg[mtch_fltr_sta_idx:SpE] / np.max(np.abs(echoref_avg[mtch_fltr_sta_idx:SpE]))) ) ) # echo*echo_conjugate
                # a[i] = np.mean( data_filt[i, mtch_fltr_sta_idx:SpE] ) # echo
            else:
                # find amplitude with echo average
                # a[i] = np.sqrt(np.mean(np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.conj( echo_avg[mtch_fltr_sta_idx:SpE] ) ) ) )  # sqrt(echo*echo_conjugate) --- wrong! because the echo average is a constant multiplier that does not change T2, but sqrt changes T2.
                a[i] = np.mean( np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.conj( echo_avg[mtch_fltr_sta_idx:SpE] / np.max(np.abs(echo_avg[mtch_fltr_sta_idx:SpE])) ) ) )  # (echo*normalize(echo_conjugate))
                # a[i] = np.mean( data_filt[i, mtch_fltr_sta_idx:SpE] ) # echo
                # a[i] = np.mean( np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.conj( echo_avg[mtch_fltr_sta_idx:SpE] / echo_avg_rms ) ) )  # (echo*normalize(echo_conjugate))
        else:
            if en_ext_matchfilter:
                # find amplitude with reference echo
                a[i] = np.mean( np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.abs( echoref_avg[mtch_fltr_sta_idx:SpE] / np.max(np.abs(echoref_avg[mtch_fltr_sta_idx:SpE]))) ) )
            else:
                # find amplitude with echo average
                a[i] = np.mean( np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.abs( echo_avg[mtch_fltr_sta_idx:SpE] / np.max(np.abs(echo_avg[mtch_fltr_sta_idx:SpE])) ) ) )  # (echo*normalize(echo_conjugate))

    asum_re = np.sum( np.real( a[ignore_echoes:] ) )
    asum_im = np.sum( np.imag( a[ignore_echoes:] ) )
    
    def dual_exp_func(x, a0, t2a, a1, t2b): # dual exponential
        return a0 * np.exp(-1/t2a * x) + a1 * np.exp(-1/t2b * x)
    def single_exp_func( x, a0, t2 ): # single exponential
        return a0 * np.exp( -1/t2 * x )

    # average the first 5% of datas
    if (not dual_exp):
        a0_guess = np.mean( np.real( a[ignore_echoes:int( np.round( SpE / 20 ) )+ignore_echoes] ) )
        # find min idx value where the value of (a0/exp) is larger than real(a)
        # b_guess = np.where(np.real(a) == np.min(np.real(a[np.real(a) > a0 / np.exp(1)])))[0][0] * tE / 1e6
        # this is dummy b_guess, use the one I made above this for smarter one (but sometimes it doesn't work)
        t2_guess = 100e-3 # in second
        guess = np.array( [a0_guess, t2_guess] )
    else:
        a0_guess = 30
        t2a_guess = 10e-3
        a1_guess = 100
        t2b_guess = 200e-3
        guess = np.array([a0_guess, t2a_guess, a1_guess, t2b_guess])
    
    try:  # try fitting data
        if (not dual_exp):
            popt, pocv = curve_fit( single_exp_func, t_echospace[ignore_echoes:], np.real(a[ignore_echoes:]), guess )
            # obtain fitting parameter
            a0 = np.zeros(1, dtype=float)
            T2 = np.zeros(1, dtype=float)
            
            a0[0] = popt[0]
            T2[0] = popt[1]
            
            # Estimate SNR/echo/scan
            f = single_exp_func( t_echospace, *popt )  # curve fit
            noise = np.std( np.imag( a[ignore_echoes:] ) )
            res = np.std( np.real( a[ignore_echoes:] ) - f[ignore_echoes:] )
            snr_imag = a0[0] / ( noise * math.sqrt( total_scan ) )
            snr_res = a0[0] / ( res * math.sqrt( total_scan ) )
            snr = snr_imag
            
        else:
            popt, pocv = curve_fit( dual_exp_func, t_echospace[ignore_echoes:], np.real(a[ignore_echoes:]), guess )
            
            a0 = np.zeros(2, dtype=float)
            T2 = np.zeros(2, dtype=float)
            
            a0[0] = popt[0]
            T2[0] = popt[1]
            a0[1] = popt[2]
            T2[1] = popt[3]
            
            # Estimate SNR/echo/scan
            f = dual_exp_func( t_echospace, *popt )  # curve fit
            noise = np.std( np.imag( a[ignore_echoes:] ) )
            res = np.std( np.real( a[ignore_echoes:] ) - f[ignore_echoes:] )
            snr_imag = np.sum(a0) / ( noise * math.sqrt( total_scan ) )
            snr_res = np.sum(a0) / ( res * math.sqrt( total_scan ) )
            snr = snr_imag

        
        
        if sav_fig:
            # plot fitted line
            plt.figure( 5 )
            plt.clf()
            plt.cla()
            plt.plot( t_echospace * 1e3, f, label = "fit" )  # plot in milisecond
            plt.plot( t_echospace * 1e3, np.real( a ) - f, label = "residue" )

    except:
        print( '     Problem in fitting. Set a0 and T2 output to 0' )
        if dual_exp:
            a0 = np.zeros(2, dtype=float)
            T2 = np.zeros(2, dtype=float)
        else:
            a0 = np.zeros(1, dtype=float)
            T2 = np.zeros(1, dtype=float)
        noise = 0
        res = 0
        snr = 0
        snr_res = 0
        snr_imag = 0

    if sav_fig:
        # plot data
        plt.figure( 5 )
        # plot in milisecond
        plt.plot( t_echospace * 1e3, np.real( a ), label = "real" )
        # plot in milisecond
        plt.plot( t_echospace * 1e3, np.imag( a ), label = "imag" )

        # plt.set(gca, 'FontSize', 12)
        plt.legend()
        if dual_exp:
            plt.title( 'Matched filtered data. SNRim:{:03.2f} SNRres:{:03.2f}.\na:{:0.3f},{:0.3f} n_im:{:0.4f} n_res:{:0.4f} T2:{:0.2f},{:0.2f}msec'.format( snr, snr_res, a0[0], a0[1], ( noise * math.sqrt( total_scan ) ), ( res * math.sqrt( total_scan ) ), T2[0] * 1e3, T2[1] * 1e3 ) )
        else:
            plt.title( 'Matched filtered data. SNRim:{:03.2f} SNRres:{:03.2f}.\na:{:0.3f} n_im:{:0.4f} n_res:{:0.4f} T2:{:0.2f}msec'.format( snr, snr_res, a0[0], ( noise * math.sqrt( total_scan ) ), ( res * math.sqrt( total_scan ) ), T2[0] * 1e3 ) )

        plt.xlabel( 'Time (mS)' )
        if (unit__uvolt_or_digit): # use either microvolt or digit (adc output) unit
            plt.ylabel( 'probe voltage (uV)' )
        else:
            plt.ylabel( 'adc out (digit)' )
        plt.savefig( data_folder + '\\decay_sum.png' )
        
        if sav_indv_dat:
            if dual_exp:
                data_parser.write_text_overwrite( data_folder, "\\decay_sum.txt", "output params: noise std: %0.5f, res std: %0.5f, snr_imag: %0.3f, snr_res: %0.3f, a0: %0.3f,%0.3f, T2: %0.3f,%0.3f ms. Format: a_real, a_imag, fit, time(s) " % ( noise, res, snr_imag, snr_res, a0[0],a0[1], T2[0] * 1e3, T2[1]*1e3 ) )
            else:
                data_parser.write_text_overwrite( data_folder, "\\decay_sum.txt", "output params: noise std: %0.5f, res std: %0.5f, snr_imag: %0.3f, snr_res: %0.3f, a0: %0.3f, T2: %0.3f ms. Format: a_real, a_imag, fit, time(s) " % ( noise, res, snr_imag, snr_res, a0[0], T2[0] * 1e3 ) )
 
            data_parser.write_text_append_row( data_folder, "\\decay_sum.txt", np.real( a ) )
            data_parser.write_text_append_row( data_folder, "\\decay_sum.txt", np.imag( a ) )
            data_parser.write_text_append_row( data_folder, "\\decay_sum.txt", f )
            data_parser.write_text_append_row( data_folder, "\\decay_sum.txt", t_echospace )

    if show_fig and sav_fig:
        plt.show()
        
    if dual_exp:
        print( 'a0 = ' + '{0:.2f}'.format( a0[0] )+ ',{0:.2f}'.format( a0[1] ) )
        print( 'T2 = ' + '{0:.4f}'.format( T2[0] * 1e3 ) + ' msec' + ',{0:.4f}'.format( T2[1] * 1e3 ) + ' msec')
    else:
        print( 'a0 = ' + '{0:.2f}'.format( a0[0] ) )
        print( 'T2 = ' + '{0:.4f}'.format( T2[0] * 1e3 ) + ' msec' )
    print( 'SNR/echo/scan = ' + 'imag:{0:.2f}, res:{1:.2f}'.format( snr, snr_res ) )
    

    return ( a, asum_re, asum_im, a0, snr, T2, noise, res, theta, data_filt, echo_avg, t_echospace )

def compute_multiexp( nmrObj, phenc_conf, expt_num, sav_fig, show_fig):

    # variables to be input
    # data_parent_folder : the folder for all datas
    # meas_folder        : the specific folder for one measurement
    # show_fig            : enable figure
    # sav_fig = False  # compute the figure and save the figure to file. To show it in runtime, enable the show_fig
    # en_ext_rotation      : enable external reference for rotation angle
    # thetaref          : external parameter : rotation angle
    # en_conj_matchfilter    : when true, matchfilter is computed with conjugate of the echo_avg. When false, matchfilter is computed only with amplitude of the echo_avg, so no rotation will be performed
    # en_ext_matchfilter : enable external reference for matched filtering
    # echoref_avg        : external parameter : echo average reference
    # ignore_echoes     : ignore initial echoes for calculation of echo_avg, T2 fitting, and SNR. It's still being shown in the plot to keep the information.

    # data_folder = ( data_parent_folder + '/' + meas_folder + '/' )
    data_folder = nmrObj.client_data_folder + nmrObj.folder_extension
    
    # load variables from phenc configs
    en_ext_rotation = phenc_conf.en_ext_rotation
    en_self_rotation = phenc_conf.en_self_rotation # perform rotation to the data -> required for reference data for t1 measurement
    thetaref = phenc_conf.thetaref
    en_conj_matchfilter = phenc_conf.en_conj_matchfilter
    en_ext_matchfilter = phenc_conf.en_ext_matchfilter
    echoref_avg = phenc_conf.echoref_avg
    dconv_lpf_ord = phenc_conf.dconv_lpf_ord
    dconv_lpf_cutoff_kHz = phenc_conf.dconv_lpf_cutoff_kHz
    ignore_echoes = phenc_conf.ignore_echoes
    a_est = phenc_conf.a_est
    t2_est = phenc_conf.t2_est
    
    
    # variables local to this function the setting file for the measurement
    mtch_fltr_sta_idx = 0  # 0 is default or something referenced to SpE, e.g. SpE/4; the start index for match filtering is to neglect ringdown part from calculation 
    proc_indv_data = False # process individual raw data, otherwise it'll load a sum file generated by C
    binary_OR_ascii = True # put 1 if the data file uses binary representation, otherwise it is in ascii format
    unit__uvolt_or_digit = False # set to 0 of ADC digit unit, or 1 for microvolt unit for all the plot 
    
    sav_indv_dat = True # save individual computed data
    
    # file name prefix for individual data
    file_name_prefix = 'dat_'
    
    # variables from NMR settings
    ( param_list, value_list ) = data_parser.parse_info( data_folder, 'acqu_%06d.par' % expt_num )  # read file
    SpE = int( data_parser.find_value( 'nrPnts', param_list, value_list ) )
    NoE = int( data_parser.find_value( 'nrEchoes', param_list, value_list ) )
    en_ph_cycle_proc = int (data_parser.find_value( 'usePhaseCycle', param_list, value_list ))
    tE = data_parser.find_value( 'echoTimeRun', param_list, value_list )
    Sf = data_parser.find_value( 'adcFreq', param_list, value_list ) * 1e6
    Df = data_parser.find_value( 'b1Freq', param_list, value_list ) * 1e6
    total_scan = int( data_parser.find_value( 'nrIterations', param_list, value_list ) )
    echo_skip = data_parser.find_value( 'echoSkipHw', param_list, value_list )

    # account for skipped echoes
    NoE = int( NoE / echo_skip )
    tE = tE * echo_skip

    # time domain for plot
    tacq = ( 1 / Sf ) * 1e6 * np.linspace( 1, SpE, SpE )  # in uS
    t_echospace = tE / 1e6 * np.linspace( 1, NoE, NoE )  # in uS

    if ( proc_indv_data ):
        # read all datas and average it
        data = np.zeros( NoE * SpE )
        for m in range( 1, total_scan + 1 ):
            file_path = ( data_folder + file_name_prefix +
                         '{0:03d}'.format( m ) )
            # read the data from the file and store it in numpy array
            # format
            one_scan = np.array( data_parser.read_data( file_path ) )
            one_scan = ( one_scan - np.mean( one_scan ) ) / \
                total_scan  # remove DC component
            if ( en_ph_cycle_proc ):
                if ( m % 2 ):  # phase cycling every other scan
                    data = data - one_scan
                else:
                    data = data + one_scan
            else:
                data = data + one_scan
        
        dataraw = data        
        
    else:
        # read sum data only
        file_path = ( data_folder + '\\dsum_%06d.txt' % expt_num )
        data = np.zeros( NoE * SpE )

        if binary_OR_ascii:
            # data = data_parser.read_hex_float( file_path )  # use binary representation
            data = data_parser.read_hex_int32 (file_path) # read int32 in binary representation
        else:
            data = np.array( data_parser.read_data( file_path ) ) # use ascii representation

        dataraw = data
        data = ( data - np.mean( data ) )

    # ignore echoes
    # if ignore_echoes:
    #    NoE = NoE - ignore_echoes
    #    data = data[ignore_echoes * SpE:len( data )]
    
    if (unit__uvolt_or_digit): # use either microvolt or digit (adc output) unit
        # compute the probe voltage before gain stage
        data = data / nmrObj.totGain * nmrObj.uvoltPerDigit
    

    if sav_fig:  # plot the averaged scan
        echo_space = ( 1 / Sf ) * np.linspace( 1, SpE, SpE )  # in s
        plt.figure( 1 )
        plt.clf()
        for i in range( 1, NoE + 1 ):
            # plt.plot(((i - 1) * tE * 1e-6 + echo_space) * 1e3, data[(i - 1) * SpE:i * SpE], linewidth=0.4)
            plt.plot( ( ( i - 1 ) * tE * 1e-6 + echo_space ) * 1e3, dataraw[( i - 1 ) * SpE:i * SpE], linewidth = 0.4 )
        plt.title( "Averaged raw data" )
        plt.xlabel( 'time(ms)' )
        if (unit__uvolt_or_digit): # use either microvolt or digit (adc output) unit
            plt.ylabel( 'probe voltage (uV)' )
        else:
            plt.ylabel( 'adc out (digit)' )
        plt.savefig( data_folder + '\\decay_raw.png' )

    # raw average data
    echo_rawavg = np.zeros( SpE, dtype = float )
    for i in range( ignore_echoes, NoE ):
        echo_rawavg += ( data[i * SpE:( i + 1 ) * SpE] / (NoE-ignore_echoes) )

    if sav_fig:  # plot echo rawavg
        plt.figure( 6 )
        plt.clf()
        plt.plot( tacq, echo_rawavg, label = 'echo rawavg' )
        plt.xlim( 0, max( tacq ) )
        plt.title( "Echo Average (raw)" )
        plt.xlabel( 'time(uS)' )
        if (unit__uvolt_or_digit): # use either microvolt or digit (adc output) unit
            plt.ylabel( 'probe voltage (uV)' )
        else:
            plt.ylabel( 'adc out (digit)' )
        plt.legend()
        plt.savefig( data_folder + '\\echo_avg.png' )

    # filter the data
    data_filt = np.zeros( ( NoE, SpE ), dtype = complex )
    for i in range( 0, NoE ):
        data_filt[i, :] = down_conv( data[i * SpE:( i + 1 ) * SpE], i, tE, Df, Sf, dconv_lpf_ord, dconv_lpf_cutoff_kHz * 1e3 )

    # scan rotation
    if en_ext_rotation:
        data_filt = data_filt * np.exp( -1j * thetaref )
        theta = math.atan2( np.sum( np.imag( data_filt[ignore_echoes:,:] ) ),
                           np.sum( np.real( data_filt[ignore_echoes:,:] ) ) )
    else:
        theta = math.atan2( np.sum( np.imag( data_filt[ignore_echoes:,:] ) ),
                           np.sum( np.real( data_filt[ignore_echoes:,:] ) ) )
        if en_self_rotation:
            data_filt = data_filt * np.exp( -1j * theta )

    if sav_fig:  # plot filtered data
        echo_space = ( 1 / Sf ) * np.linspace( 1, SpE, SpE )  # in s
        plt.figure( 2 )
        plt.clf()
        
        if sav_indv_dat:
            data_parser.write_text_overwrite( data_folder, "\\decay_filt.txt", "settings: NoE: %d, SpE: %d, tE: %0.2f, fs: %0.2f. Format: re(echo1), im(echo1), re(echo2), im(echo2), ... " % ( NoE, SpE, tE, Sf ) )

        for i in range( 0, NoE ):
            plt.plot( ( i * tE * 1e-6 + echo_space ) * 1e3, np.real( data_filt[i, :] ), 'b', linewidth = 0.4 )
            plt.plot( ( i * tE * 1e-6 + echo_space ) * 1e3, np.imag( data_filt[i, :] ), 'r', linewidth = 0.4 )
        
        if sav_indv_dat:
            for i in range ( 0, NoE ):
                data_parser.write_text_append_row( data_folder, "\\decay_filt.txt", np.real( data_filt[i, :] ) )
                data_parser.write_text_append_row( data_folder, "\\decay_filt.txt", np.imag( data_filt[i, :] ) )

        plt.legend()
        plt.title( 'Filtered data' )
        plt.xlabel( 'Time (mS)' )
        if (unit__uvolt_or_digit): # use either microvolt or digit (adc output) unit
            plt.ylabel( 'probe voltage (uV)' )
        else:
            plt.ylabel( 'adc out (digit)' )
        plt.savefig( data_folder + '\\decay_filt.png' )

    # find echo average, echo magnitude
    echo_avg = np.zeros( SpE, dtype = complex )
    for i in range( ignore_echoes, NoE ):
        echo_avg += ( data_filt[i, :] / NoE )
    echo_avg_rms = np.sqrt(np.sum(np.multiply(np.abs(echo_avg),np.abs(echo_avg)))) # find the rms value

    if sav_fig:  # plot echo shape
        plt.figure( 3 )
        plt.clf()
        plt.plot( tacq, np.abs( echo_avg ), label = 'abs' )
        plt.plot( tacq, np.real( echo_avg ), label = 'real part' )
        plt.plot( tacq, np.imag( echo_avg ), label = 'imag part' )
        plt.xlim( 0, max( tacq ) )
        plt.title( "Echo Shape" )
        plt.xlabel( 'time(uS)' )
        if (unit__uvolt_or_digit): # use either microvolt or digit (adc output) unit
            plt.ylabel( 'probe voltage (uV)' )
        else:
            plt.ylabel( 'adc out (digit)' )
        plt.legend()
        plt.savefig( data_folder + '\\echo_shape.png' )
        
        if sav_indv_dat:
            data_parser.write_text_overwrite( data_folder, "\\echo_shape.txt", "format: abs, real, imag, time_us" )
            data_parser.write_text_append_row( data_folder, "\\echo_shape.txt", np.abs( echo_avg ) )
            data_parser.write_text_append_row( data_folder, "\\echo_shape.txt", np.real( echo_avg ) )
            data_parser.write_text_append_row( data_folder, "\\echo_shape.txt", np.imag( echo_avg ) )
            data_parser.write_text_append_row( data_folder, "\\echo_shape.txt", tacq )

        # plot echo spectrum
        plt.figure( 4 )
        plt.clf()
        zf = 10  # zero filling factor to get smooth curve. Factor 1 means the resulting vector length is added by the amount of the original vector length itself.
        if zf>0: # process zero filling
            ws = 2 * np.pi / ( tacq[1] - tacq[0] )  # in MHz
            wvect = np.linspace( -ws / 2, ws / 2, len( tacq ) * zf )
            echo_zf = np.zeros( zf * len( echo_avg ), dtype = complex )
            echo_zf[int( ( zf / 2 ) * len( echo_avg ) - len( echo_avg ) / 2 ): int( ( zf / 2 ) * len( echo_avg ) + len( echo_avg ) / 2 )] = echo_avg
            spect = zf * ( np.fft.fftshift( np.fft.fft( np.fft.ifftshift( echo_zf ) ) ) )
            spect = spect / len( spect )  # normalize the spectrum
        else: #ignore zero filling
            ws = 2 * np.pi / ( tacq[1] - tacq[0] )  # in MHz
            wvect = np.linspace( -ws / 2, ws / 2, len( tacq ) )
            spect =  ( np.fft.fftshift( np.fft.fft( np.fft.ifftshift( echo_avg ) ) ) )
            spect = spect / len(spect)
            
        plt.plot( wvect / ( 2 * np.pi ), np.real( spect ), label = 'real' )
        plt.plot( wvect / ( 2 * np.pi ), np.imag( spect ), label = 'imag' )
        plt.xlim( 10 / max( tacq ) * -1, 10 / max( tacq ) * 1 )
        plt.title( "Echo spectrum. " + "Peak:real@{:0.2f}kHz,abs@{:0.2f}kHz".format( wvect[np.abs( np.real( spect ) ) == max( 
            np.abs( np.real( spect ) ) )][0] / ( 2 * np.pi ) * 1e3, wvect[np.abs( spect ) == max( np.abs( spect ) )][0] / ( 2 * np.pi ) * 1e3 ) )
        plt.xlabel( 'offset frequency(MHz)' )
        plt.ylabel( 'Echo amplitude (a.u.)' )
        plt.legend()
        plt.savefig( data_folder + '\\echo_spect.png' )
        
        if sav_indv_dat:
            data_parser.write_text_overwrite( data_folder, "\\echo_spect.txt", "format: real, imag, freq_MHz" )
            data_parser.write_text_append_row( data_folder, "\\echo_spect.txt", np.real( spect ) )
            data_parser.write_text_append_row( data_folder, "\\echo_spect.txt", np.imag( spect ) )
            data_parser.write_text_append_row( data_folder, "\\echo_spect.txt", wvect / ( 2 * np.pi ) )

    # matched filtering
    a = np.zeros( NoE, dtype = complex )
    for i in range( 0, NoE ):
        if en_conj_matchfilter:
            if en_ext_matchfilter:
                # find amplitude with reference echo
                # a[i] = np.sqrt(np.mean( np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.conj( echoref_avg[mtch_fltr_sta_idx:SpE] ) ) ) ) # sqrt(echo*echo_conjugate) --- wrong! because the echo average is a constant multiplier that does not change T2, but sqrt changes T2.
                a[i] = np.mean( np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.conj( echoref_avg[mtch_fltr_sta_idx:SpE] / np.max(np.abs(echoref_avg[mtch_fltr_sta_idx:SpE]))) ) ) # echo*echo_conjugate
                # a[i] = np.mean( data_filt[i, mtch_fltr_sta_idx:SpE] ) # echo
            else:
                # find amplitude with echo average
                # a[i] = np.sqrt(np.mean(np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.conj( echo_avg[mtch_fltr_sta_idx:SpE] ) ) ) )  # sqrt(echo*echo_conjugate) --- wrong! because the echo average is a constant multiplier that does not change T2, but sqrt changes T2.
                a[i] = np.mean( np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.conj( echo_avg[mtch_fltr_sta_idx:SpE] / np.max(np.abs(echo_avg[mtch_fltr_sta_idx:SpE])) ) ) )  # (echo*normalize(echo_conjugate))
                # a[i] = np.mean( data_filt[i, mtch_fltr_sta_idx:SpE] ) # echo
                # a[i] = np.mean( np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.conj( echo_avg[mtch_fltr_sta_idx:SpE] / echo_avg_rms ) ) )  # (echo*normalize(echo_conjugate))
        else:
            if en_ext_matchfilter:
                # find amplitude with reference echo
                a[i] = np.mean( np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.abs( echoref_avg[mtch_fltr_sta_idx:SpE] / np.max(np.abs(echoref_avg[mtch_fltr_sta_idx:SpE]))) ) )
            else:
                # find amplitude with echo average
                a[i] = np.mean( np.multiply( data_filt[i, mtch_fltr_sta_idx:SpE], np.abs( echo_avg[mtch_fltr_sta_idx:SpE] / np.max(np.abs(echo_avg[mtch_fltr_sta_idx:SpE])) ) ) )  # (echo*normalize(echo_conjugate))

    asum_re = np.sum( np.real( a[ignore_echoes:] ) )
    asum_im = np.sum( np.imag( a[ignore_echoes:] ) )
    
    def dual_exp_func(x, a0, t2a, a1, t2b): # dual exponential
        return a0 * np.exp(-1/t2a * x) + a1 * np.exp(-1/t2b * x)
    def single_exp_func( x, a0, t2 ): # single exponential
        return a0 * np.exp( -1/t2 * x )
    def multiexp_func (x, *a_t2_list): # multi-exponential fitting
        f = 0
        n = len(a_t2_list)
        for ii in range(n>>1):
            f = f + a_t2_list[ii] * np.exp(-1/a_t2_list[ii+(n>>1)]*x)
        return f 
    
    try:  # try fitting data

        popt, pocv = curve_fit (multiexp_func, t_echospace[ignore_echoes:], np.real(a[ignore_echoes:]), [a_est, t2_est])
        a0 = popt[:len(a_est)]
        T2 = popt[len(a_est):]
        
        f = multiexp_func (t_echospace, *popt)
        noise = np.std( np.imag( a[ignore_echoes:] ) )
        res = np.std( np.real( a[ignore_echoes:] ) - f[ignore_echoes:] )
        snr_imag = np.sum(a0) / ( noise * math.sqrt( total_scan ) )
        snr_res = np.sum(a0) / ( res * math.sqrt( total_scan ) )
        snr = snr_imag
        
        if sav_fig:
            # plot fitted line
            plt.figure( 5 )
            plt.clf()
            plt.cla()
            plt.plot( t_echospace * 1e3, f, label = "fit" )  # plot in milisecond
            plt.plot( t_echospace * 1e3, np.real( a ) - f, label = "residue" )

    except:
        print( '     Problem in fitting. Set a0 and T2 output to 0' )
        
        a0 = np.zeros(len(a_est), dtype=float)
        T2 = np.zeros(len(t2_est), dtype=float)
        
        noise = 0
        res = 0
        snr = 0
        snr_res = 0
        snr_imag = 0

    if sav_fig:
        # plot data
        plt.figure( 5 )
        plt.plot( t_echospace * 1e3, np.real( a ), label = "real" ) # plot in milisecond
        plt.plot( t_echospace * 1e3, np.imag( a ), label = "imag" ) # plot in milisecond

        # plt.set(gca, 'FontSize', 12)
        plt.legend()
        plt.title( 'Matched filtered data. SNRim:{:03.2f} SNRres:{:03.2f}.\na:{:s} n_im:{:0.4f} n_res:{:0.4f} T2:{:s}msec'.format( snr, snr_res, np.array_str(a0,precision=2), ( noise * math.sqrt( total_scan ) ), ( res * math.sqrt( total_scan ) ), np.array_str(T2*1e3,precision=2) ) )

        plt.xlabel( 'Time (mS)' )
        if (unit__uvolt_or_digit): # use either microvolt or digit (adc output) unit
            plt.ylabel( 'probe voltage (uV)' )
        else:
            plt.ylabel( 'adc out (digit)' )
        plt.savefig( data_folder + '\\decay_sum.png' )
        
        if sav_indv_dat:
            data_parser.write_text_overwrite( data_folder, "\\decay_sum.txt", "output params: noise std: %0.5f, res std: %0.5f, snr_imag: %0.3f, snr_res: %0.3f, a0: %s, T2: %s ms. Format: a_real, a_imag, fit, time(s) " % ( noise, res, snr_imag, snr_res, np.array_str(a0,precision=2), np.array_str(T2*1e3,precision=2) ) )          
            data_parser.write_text_append_row( data_folder, "\\decay_sum.txt", np.real( a ) )
            data_parser.write_text_append_row( data_folder, "\\decay_sum.txt", np.imag( a ) )
            data_parser.write_text_append_row( data_folder, "\\decay_sum.txt", f )
            data_parser.write_text_append_row( data_folder, "\\decay_sum.txt", t_echospace )

    if show_fig and sav_fig:
        plt.show()
    
    print( 'a0 = %s' % np.array_str(a0,precision=2))
    print( 'T2 = %s ms' % np.array_str(T2*1e3,precision=2))
    print( 'SNR/echo/scan = ' + 'imag:{0:.2f}, res:{1:.2f}'.format( snr, snr_res ) )
    
    return ( a, asum_re, asum_im, a0, snr, T2, noise, res, theta, data_filt, echo_avg, t_echospace )

def compute_in_bw_noise( en_filt, bw_kHz, filt_ord, Df_MHz, minfreq, maxfreq, data_parent_folder, plotname, en_fig ):

    # variables to be input
    # en_filt            : enable the software post-processing filter to limit the measurement bandwidth
    # data_parent_folder : the folder for all datas
    # bw_kHz            : filter bandwidth
    # filt_ord : filter order
    # en_fig            : enable figure

    # compute settings

    data_folder = ( data_parent_folder + '/' )
    fig_num = 200

    # variables from NMR settings
    ( param_list, value_list ) = data_parser.parse_info( 
        data_folder, 'acqu.par' )  # read file
    adcFreq = data_parser.find_value( 
        'adcFreq', param_list, value_list )
    nrPnts = int( data_parser.find_value( 
        'samples', param_list, value_list ) )

    # parse file and remove DC component
    nmean = 0
    file_path = ( data_folder + 'noise.txt' )
    one_scan_raw = np.array( data_parser.read_data( file_path ) )
    nmean = np.mean( one_scan_raw )
    one_scan = ( one_scan_raw - nmean )

    # compute in-bandwidth noise
    Sf = adcFreq * 1e6
    # filter parameter
    # filt_ord = 2
    filt_lpf_cutoff = bw_kHz * 1e3  # in Hz

    T = 1 / Sf
    t = np.linspace( 0, T * ( len( one_scan ) - 1 ), len( one_scan ) )

    

    # filter one_scan when filter is enabled. Otherwise, leave one_scan
    if (en_filt):
        # down-conversion
        sReal = one_scan * np.cos( 2 * math.pi * Df_MHz * 1e6 * t )
        sImag = one_scan * np.sin( 2 * math.pi * Df_MHz * 1e6 * t )
        r = butter_lowpass_filter( sReal + 1j * sImag, filt_lpf_cutoff, Sf, filt_ord, False ) # filtered value
        # upconversion
        one_scan = np.real( r ) * np.cos( 2 * math.pi * Df_MHz * 1e6 * t ) + np.imag( r ) * np.sin( 2 * math.pi * Df_MHz * 1e6 * t )  # r * e^(j*w0*t)
        # one_scan = np.real( one_scan ) # not needed, the result above contains only real values

    # filter profile
    filt_prfl = np.random.randn( len( one_scan ) )  # generate ones
    filt_prfl_ori = filt_prfl  # noise data with no filter process
    sfiltReal = filt_prfl * np.cos( 2 * math.pi * Df_MHz * 1e6 * t )  # real downconversion
    sfiltImag = filt_prfl * np.sin( 2 * math.pi * Df_MHz * 1e6 * t )  # imag downconversion
    filt_out = butter_lowpass_filter( sfiltReal + 1j * sfiltImag, filt_lpf_cutoff, Sf, filt_ord, False )  # filter
    filt_prfl = np.real( filt_out ) * np.cos( 2 * math.pi * Df_MHz * 1e6 * t ) + np.imag( filt_out ) * np.sin( 2 * math.pi * Df_MHz * 1e6 * t )  # upconversion
    # filt_prfl = np.real( filt_prfl ) # no need. the value is already real

    # compute fft
    spectx, specty = nmr_fft( one_scan, adcFreq, 0 )
    specty = abs( specty )
    fft_range = [i for i, value in enumerate( spectx ) if ( 
        value >= minfreq and value <= maxfreq )]  # limit fft display

    # compute fft for the filter profile
    filtspectx, filtspecty = nmr_fft( filt_prfl, adcFreq, 0 )
    filtspecty = abs( filtspecty )
    filtorispecx, filtorispecty = nmr_fft( filt_prfl_ori, adcFreq, 0 )  # noise data with no filter process
    filtorispecty = abs( filtorispecty )

    # compute std
    nstd = np.std( one_scan )

    if en_fig:
        plt.ion()
        fig = plt.figure( fig_num )

        # maximize window
        plot_backend = matplotlib.get_backend()
        mng = plt.get_current_fig_manager()
        if plot_backend == 'TkAgg':
            # mng.resize(*mng.window.maxsize())
            mng.resize( 1400, 800 )
        elif plot_backend == 'wxAgg':
            mng.frame.Maximize( True )
        elif plot_backend == 'Qt4Agg':
            mng.window.showMaximized()

        fig.clf()
        ax = fig.add_subplot( 311 )

        filtnorm = sum( specty[fft_range] ) / sum( filtspecty[fft_range] )

        line1, = ax.plot( spectx[fft_range], specty[fft_range], 'b-', label = 'data', linewidth = 0.5 )
        # line2, = ax.plot( filtspectx[fft_range], filtspecty[fft_range] * filtnorm, 'r.', markersize = 0.8, label = 'synth. noise' )  # amplitude is normalized with the max value of specty
        # line3, = ax.plot(filtorispecx[fft_range], filtorispecty[fft_range]*(filtnorm/2), 'y.', markersize=2.0, label='synth. noise unfiltered') # amplitude is normalized with the max value of specty

        # ax.set_ylim(0, 60)
        ax.set_xlabel( 'Frequency (MHz)' )
        ax.set_ylabel( 'Amplitude (a.u.)' )
        ax.set_title( "Spectrum" )
        ax.grid()
        ax.legend()
        # plt.ylim( [-0.2, 5] )

        # plot time domain data
        ax = fig.add_subplot( 312 )
        x_time = np.linspace( 1, len( one_scan_raw ), len( one_scan_raw ) )
        x_time = np.multiply( x_time, ( 1 / adcFreq ) )  # in us
        x_time = np.multiply( x_time, 1e-3 )  # in ms
        line1, = ax.plot( x_time, one_scan, 'b-' , linewidth = 0.5 )
        ax.set_xlabel( 'Time(ms)' )
        ax.set_ylabel( 'Amplitude (a.u.)' )
        ax.set_title( "Amplitude. std=%0.2f. mean=%0.2f." % ( nstd, nmean ) )
        ax.grid()
        '''
        if (en_filt):
            plt.ylim( [-2000, 2000] )
        else:
            plt.ylim( [-2000, 2000] )
        '''

        # plot histogram
        n_bins = 200
        ax = fig.add_subplot( 313 )
        n, bins, patches = ax.hist( one_scan, bins = n_bins )
        ax.set_title( "Histogram" )
        # plt.ylim( [0, 2000] )

        plt.tight_layout()
        fig.canvas.draw()
        fig.canvas.flush_events()

        # fig = plt.gcf() # obtain handle
        plt.savefig( data_folder + plotname )

    # standard deviation of signal
    print( '\t\t: rms= ' + '{0:.4f}'.format( nstd ) +
          ' mean= {0:.4f}'.format( nmean ) )
    return nstd, nmean

def calcP90( Vpp, rs, L, f, numTurns, coilLength, coilFactor ):

    # estimates the 90 degree pulse length based on voltage output at the coil
    # Vpp: measured voltage at the coil
    # rs: series resitance of coil
    # L: inductance of coil
    # f: Larmor frequency in Hz
    # numTurns: Number of turns in coil
    # coilLength: Length of coil in m
    # coilFactor: obtained by measurement compensation with KeA, will be coil geometry
    # dependant

    import math
    import numpy as np

    gamma = 42.58e6  # MHz/Tesla
    u = 4 * np.pi * 10 ** -7
    Q = 2 * np.pi * f * L / rs
    Vrms = Vpp / ( 2 * math.sqrt( 2 ) )
    Irms = Vrms / ( math.sqrt( Q ** 2 + 1 ** 2 ) * rs )

    # extra factor due to finite coil length (geometry)
    B1 = u * ( numTurns / ( 2 * coilLength ) ) * Irms / coilFactor
    P90 = ( 1 / ( gamma * B1 ) ) * ( 90 / 360 )
    Pwatt = ( Irms ** 2 ) * rs

    return P90, Pwatt

